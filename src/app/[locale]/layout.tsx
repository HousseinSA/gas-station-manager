import type { Metadata } from "next"
import "../globals.css"
import { NextIntlClientProvider } from "next-intl"
import fs from "fs"
import path from "path"

export const metadata: Metadata = {
  title: "Gestion Stations-Service",
  description: "Generated by create next app",
}

function getLocaleFromCookie(headers: Headers) {
  const cookie = headers.get("cookie") || ""
  const match = cookie.match(/(^|;)\s*NEXT_LOCALE=([^;]+)/)
  return match ? decodeURIComponent(match[2]) : "fr"
}

function hasUserCookie(headers: Headers) {
  const cookie = headers.get("cookie") || ""
  const match = cookie.match(/(?:^|; )userId=(\d+)/)
  return !!match
}

// This layout is nested under /[locale]. The router passes the active locale
// in the `params` prop. Prefer the path param first, then cookie, then default.
export default async function RootLayout({
  children,
  params,
  headers,
}: Readonly<{
  children: React.ReactNode
  params: { locale?: string }
  headers?: Headers
}>) {
  const paramLocale = params?.locale
  const locale =
    paramLocale || getLocaleFromCookie(headers ?? new Headers()) || "fr"

  const tryPaths = [
    path.join(process.cwd(), "messages", `${locale}.json`),
    path.join(process.cwd(), "locales", `${locale}.json`),
  ]
  let messages: Record<string, any> = {}
  for (const p of tryPaths) {
    try {
      if (fs.existsSync(p)) {
        const raw = fs.readFileSync(p, "utf-8")
        messages = JSON.parse(raw)
        break
      }
    } catch (e) {
      console.warn(`Could not load locale messages from ${p}`, e)
    }
  }

  const userPresent = hasUserCookie(headers ?? new Headers())

  return (
    <html lang={locale} dir={locale === "ar" ? "rtl" : "ltr"}>
      <body>
        <NextIntlClientProvider locale={locale} messages={messages}>
          {children}
        </NextIntlClientProvider>
      </body>
    </html>
  )
}
